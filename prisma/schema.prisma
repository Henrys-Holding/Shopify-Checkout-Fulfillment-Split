// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

enum AdditionalShippingRequestStatus {
  PENDING // Initial state
  APP_DISABLED
  AWAITING_PAYMENT // Invoice sent, waiting for customer
  COMPLETED // Paid and Primary Order released
  CANCELLED // Failed to pay within 24h or manual cancel
  FAILED // System error during processing
}

// 1. Define the data source (PostgreSQL for Supabase)
datasource db {
  provider = "postgresql" // Supabase uses PostgreSQL
  url      = env("DIRECT_URL") // This is loaded from your .env file
}

// 2. Define the generator (Prisma Client)
generator client {
  provider = "prisma-client-js"
}

model session {
  id                  String    @id
  shop                String
  state               String
  isOnline            Boolean   @default(false)
  scope               String?
  expires             DateTime?
  accessToken         String
  userId              BigInt?
  firstName           String?
  lastName            String?
  email               String?
  accountOwner        Boolean   @default(false)
  locale              String?
  collaborator        Boolean?  @default(false)
  emailVerified       Boolean?  @default(false)
  refreshToken        String?
  refreshTokenExpires DateTime?
}

// ==========================================
// CORE PLATFORM TABLES
// (Generic: Usable by any app/feature)
// ==========================================

model Shop {
  shop_domain    String    @id
  installed_at   DateTime  @default(now())
  uninstalled_at DateTime?

  // Relations
  orders                              Order[]
  customers                           Customer[]
  products                            Product[]
  additional_shipping_requests        AdditionalShippingRequest[]
  additional_shipping_request_setting AdditionalShippingRequestSetting?

  @@map("core_shops")
}

model Customer {
  customer_id String  @id
  email       String?
  first_name  String?
  last_name   String?

  shop_domain String
  shop        Shop   @relation(fields: [shop_domain], references: [shop_domain])

  orders Order[]

  @@map("core_customers")
}

model Product {
  product_gid String  @id
  title       String
  handle      String?

  shop_domain String
  shop        Shop   @relation(fields: [shop_domain], references: [shop_domain])

  @@map("core_products")
}

model Order {
  order_id    String   @id
  order_name  String
  shop_domain String
  created_at  DateTime
  updated_at  DateTime

  // Distinguish between a regular order and one created just for shipping payment
  is_shipping_payment_order Boolean @default(false)

  // Relations (inverse sides, no fields/references here)
  additional_shipping_request AdditionalShippingRequest? @relation("PrimaryOrder")
  originating_request         AdditionalShippingRequest? @relation("PaymentOrder")

  shop        Shop?     @relation(fields: [shop_domain], references: [shop_domain])
  customer    Customer? @relation(fields: [customer_id], references: [customer_id])
  customer_id String?

  @@map("core_orders")
}

model AdditionalShippingRequestSetting {
  id Int @id @default(autoincrement())

  // Foreign Key
  // @unique is CRITICAL here. It enforces that one shop can only have one settings record.
  shop_domain String @unique

  // Relation Definition
  shop Shop @relation(fields: [shop_domain], references: [shop_domain])

  app_enabled Boolean @default(false)

  @@map("additional_shipping_request_settings")
}

model AdditionalShippingRequest {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid

  // 1. The original order that needs splitting (required 1–1)
  primary_order_id String @unique
  primary_order    Order  @relation("PrimaryOrder", fields: [primary_order_id], references: [order_id])

  // 2. The new order Shopify creates AFTER the draft order is paid (optional 1–1)
  payment_order_id String? @unique
  payment_order    Order?  @relation("PaymentOrder", fields: [payment_order_id], references: [order_id])

  // New Tracking Fields
  primary_order_cancelled_at DateTime?
  payment_order_cancelled_at DateTime?

  // App Logic
  user_choice                Boolean?
  calculated_parcels         Int                             @default(1)
  additional_shipping_amount Decimal?                        @db.Decimal(10, 2)
  status                     AdditionalShippingRequestStatus @default(PENDING)

  // Payment Tracking
  draft_order_id  String?   @unique
  invoice_url     String?
  invoice_sent_at DateTime?

  // The "Death Clock" for the 24hr cancellation logic
  expires_at DateTime?

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  shop_domain String
  shop        Shop   @relation(fields: [shop_domain], references: [shop_domain])

  // Error Logging
  error_log String?

  // Relations
  fulfillment_holds AdditionalShippingRequestFulfillmentHold[] @relation("AdditionalShippingRequest")

  @@map("additional_shipping_requests")
}

model AdditionalShippingRequestFulfillmentHold {
  fulfillment_hold_id  String @id
  fulfillment_order_id String

  released Boolean @default(false)

  additional_shipping_request_id String                    @db.Uuid
  additional_shipping_request    AdditionalShippingRequest @relation("AdditionalShippingRequest", fields: [additional_shipping_request_id], references: [id])

  @@map("additional_shipping_request_fulfillment_holds")
}
