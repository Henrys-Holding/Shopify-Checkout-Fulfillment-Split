// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

enum AdditionalShippingRequestStatus {
  PENDING // Initial state
  APP_DISABLED
  AWAITING_PAYMENT // Invoice sent, waiting for customer
  COMPLETED // Paid and Primary Order released
  CANCELLED // Failed to pay within 24h or manual cancel
  FAILED // System error during processing
}

// 1. Define the data source (PostgreSQL for Supabase)
datasource db {
  provider = "postgresql" // Supabase uses PostgreSQL
  url      = env("DIRECT_URL") // This is loaded from your .env file
}

// 2. Define the generator (Prisma Client)
generator client {
  provider = "prisma-client-js"
}

model session {
  id                  String    @id
  shop                String
  state               String
  isOnline            Boolean   @default(false)
  scope               String?
  expires             DateTime?
  accessToken         String
  userId              BigInt?
  firstName           String?
  lastName            String?
  email               String?
  accountOwner        Boolean   @default(false)
  locale              String?
  collaborator        Boolean?  @default(false)
  emailVerified       Boolean?  @default(false)
  refreshToken        String?
  refreshTokenExpires DateTime?
}

// ==========================================
// CORE PLATFORM TABLES
// (Generic: Usable by any app/feature)
// ==========================================

model Shop {
  shop_domain    String    @id
  installed_at   DateTime  @default(now())
  uninstalled_at DateTime?

  // Relations
  orders                              Order[]
  customers                           Customer[]
  products                            Product[]
  additional_shipping_requests        AdditionalShippingRequest[]
  additional_shipping_request_setting AdditionalShippingRequestSetting?

  @@map("core_shops")
}

model Customer {
  customer_id String  @id
  email       String?
  first_name  String?
  last_name   String?

  shop_domain String
  shop        Shop   @relation(fields: [shop_domain], references: [shop_domain])

  orders Order[]

  @@map("core_customers")
}

model Product {
  product_gid String  @id
  title       String
  handle      String?

  shop_domain String
  shop        Shop   @relation(fields: [shop_domain], references: [shop_domain])

  @@map("core_products")
}

model Order {
  order_id    String   @id
  order_name  String
  shop_domain String
  created_at  DateTime
  updated_at  DateTime

  // Distinguish between a regular order and one created just for shipping payment
  is_shipping_payment_order Boolean @default(false)

  // Relations (inverse sides, no fields/references here)
  additional_shipping_request AdditionalShippingRequest? @relation("PrimaryOrder")
  originating_request         AdditionalShippingRequest? @relation("PaymentOrder")

  shop                        Shop?                   @relation(fields: [shop_domain], references: [shop_domain])
  customer                    Customer?               @relation(fields: [customer_id], references: [customer_id])
  customer_id                 String?
  credit_card_verification    CreditCardVerification? @relation(fields: [credit_card_verification_id], references: [id])
  credit_card_verification_id String?                 @db.Uuid

  cancelled_at                                 DateTime?
  
  credit_card_verification_request_fulfillment_holds CreditCardVerificationRequestFulfillmentHold[]
  
  @@map("core_orders")
}

model AdditionalShippingRequestSetting {
  id Int @id @default(autoincrement())

  // Foreign Key
  // @unique is CRITICAL here. It enforces that one shop can only have one settings record.
  shop_domain String @unique

  // Relation Definition
  shop Shop @relation(fields: [shop_domain], references: [shop_domain])

  app_enabled Boolean @default(false)

  @@map("additional_shipping_request_settings")
}

model AdditionalShippingRequest {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid

  // 1. The original order that needs splitting (required 1–1)
  primary_order_id String @unique
  primary_order    Order  @relation("PrimaryOrder", fields: [primary_order_id], references: [order_id])

  // 2. The new order Shopify creates AFTER the draft order is paid (optional 1–1)
  payment_order_id String? @unique
  payment_order    Order?  @relation("PaymentOrder", fields: [payment_order_id], references: [order_id])

  // New Tracking Fields
  primary_order_cancelled_at DateTime?
  payment_order_cancelled_at DateTime?

  // App Logic
  user_choice                Boolean?
  calculated_parcels         Int                             @default(1)
  additional_shipping_amount Decimal?                        @db.Decimal(10, 2)
  status                     AdditionalShippingRequestStatus @default(PENDING)
  shipping_level             Int?

  // Payment Tracking
  draft_order_id  String?   @unique
  invoice_url     String?
  invoice_sent_at DateTime?

  // The "Death Clock" for the 24hr cancellation logic
  expires_at DateTime?

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  shop_domain String
  shop        Shop   @relation(fields: [shop_domain], references: [shop_domain])

  // Error Logging
  error_log String?

  // Relations
  fulfillment_holds AdditionalShippingRequestFulfillmentHold[] @relation("AdditionalShippingRequest")

  @@map("additional_shipping_requests")
}

model AdditionalShippingRequestFulfillmentHold {
  fulfillment_hold_id  String @id
  fulfillment_order_id String

  released Boolean @default(false)

  additional_shipping_request_id String                    @db.Uuid
  additional_shipping_request    AdditionalShippingRequest @relation("AdditionalShippingRequest", fields: [additional_shipping_request_id], references: [id])

  @@map("additional_shipping_request_fulfillment_holds")
}

// Migrate From Credit Card Verification
model CreditCardVerificationSetting {
  id                       Int     @id @default(autoincrement())
  shop                     String  @unique
  app_domain               String?
  enabled                  Boolean @default(true)
  auto_change_order_status Boolean @default(true)

  @@map("credit_card_verification_settings")
}

model CreditCardVerification {
  id                  String                        @id @default(uuid()) @db.Uuid
  customer_id         String
  customer_name       String
  customer_email      String
  customer_locale     String?
  shipping_country    String?
  internal_notes      String?
  shop                String
  credit_card_number  String
  credit_card_bin     Int
  bin_lookup          CreditCardBinLookup?          @relation(fields: [bin_lookup_id], references: [id])
  bin_lookup_id       Int?
  credit_card_company String
  submission_time     DateTime?
  attempt_count       Int                           @default(0)
  status              CreditCardVerificationStatus  @default(PENDING_SUBMISSION)
  images              CreditCardVerificationImage[]
  created_at          DateTime                      @default(now())
  updated_at          DateTime                      @updatedAt
  token               String
  risk_level          CreditCardRiskLevel?
  risk_recommendation CreditCardRiskRecommendation?

  orders            Order[]
  follow_up         Boolean?                                       @default(false)
  fulfillment_holds CreditCardVerificationRequestFulfillmentHold[] @relation("CreditCardVerification")

  @@unique([shop, credit_card_number, customer_id, credit_card_bin])
  @@map("credit_card_verifications")
}

model CreditCardVerificationImage {
  id                          Int                    @id @default(autoincrement())
  credit_card_verification_id String                 @db.Uuid
  credit_card_verification    CreditCardVerification @relation(fields: [credit_card_verification_id], references: [id])
  s3_file_key                 String                 @unique

  @@map("credit_card_verification_images")
}

model CreditCardBinLookup {
  id                       Int                      @id @default(autoincrement())
  bin                      Int                      @unique
  bank                     String
  country                  String?
  country_code             String?
  type                     String?
  scheme                   String?
  url                      String?
  credit_card_verification CreditCardVerification[]

  @@map("credit_card_bin_lookups")
}

model CreditCardVerificationRequestFulfillmentHold {
  fulfillment_hold_id  String @unique
  fulfillment_order_id String @id

  released Boolean @default(false)

  credit_card_verification_id String                 @db.Uuid
  credit_card_verification    CreditCardVerification @relation("CreditCardVerification", fields: [credit_card_verification_id], references: [id])

  order_id String
  order    Order  @relation(fields: [order_id], references: [order_id])

  @@map("credit_card_verification_fulfillment_holds")
}

enum CreditCardVerificationStatus {
  PENDING_SUBMISSION
  PENDING_VERIFICATION
  DENIED
  APPROVED
  ATTEMPTS_EXCEEDED
}

enum CreditCardRiskLevel {
  LOW
  MEDIUM
  HIGH
  NONE
  PENDING
}

enum CreditCardRiskRecommendation {
  ACCEPT
  CANCEL
  INVESTIGATE
  NONE
}

enum CreditCardOrderStatus {
  HOLD
  RELEASED
  CANCELED
}
